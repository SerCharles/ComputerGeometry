# 最远点对实验报告

软博21 沈冠霖 2021312593

## 1.整体思路

这道题的思路是这样的：对于一个点集S，其最远点对必然位于凸包上，而且至少有一对最远点对两个都是角点。因此只需要把这些线的交点的凸包求出来，只保留角点，再求凸包上的最远点即可。

和陈嘉杰同学交流后，我参考了论文Computing the Convex Hull of Line Intersections和博客博客 https://zhuanlan.zhihu.com/p/81774256进行实现。上述论文假设不存在平行线、重合线和多点共线，具体流程如下：

1. 把所有的直线y=kx+b按照k从小到大排序
2. 对于每条直线，和列表中的下一条直线求交点，加入有效点集S。最后一条直线要和列表中第一条直线求交点
3. 对有效点集S使用Graham Scan算法求凸包
4. 遍历凸包的点，只保留角点
5. 使用旋转卡壳算法

这篇论文的核心思想是这样的：假设三条直线a, b, c有斜率k_a < k_b < k_c，而且这三条直线并不是直线集合的全部，那么直线a和c的交点必然不是角点。具体证明参见论文，这里不再赘述。这样就能排除绝大多数线和线的交点。

按照这篇论文的思路，求凸包的算法是O(nlogn)：第一步排序是O(nlogn)，第二步求交是O(n)而且会产生n个点，第三步求凸包是O(nlogn)，第四步遍历清理是O(n)，第五步旋转卡壳算法是O(n)。这样整体复杂度就是O(nlogn)。

## 2.实际操作

实际上我并没有严格按照上面的流程完成。

首先，虽然没有重合线，但是本论文并不能解决平行线的问题，因此需要特殊处理。在算法的第1步，我把按照k排好序的直线按照斜率k分组，每组内的线互相平行。在算法的第2步，我是按照直线组来求交的：对于第i组直线，我们把这里每条直线和第i+1组的每条直线都要求交，交点加入有效点集S。而且最后一组直线也要和第一组直线求交点。这样做的话，仍然能排除论文所说的，必然不是角点的交点，大大提高算法效率。而这样做，当平行线过多的时候，交点个数仍然会退化到O(n^2)，因此我做了个特殊判断，首先处理所有直线都平行的情况，避免退化，引入了一个O(n)的操作，不影响整体复杂度。

其次，多点共线问题也需要处理，否则会影响Graham Scan算法。在算法第2步后，我按照LTL原则（Lowest then Leftmost）将所有的点排序，然后清理掉重复的点（定义为和列表里上一个点欧几里得距离小于1e-12）。引入的操作复杂度为O(nlogn)，不影响整体复杂度。

最终，虽然旋转卡壳算法可以把最后一步复杂度降低到O(m)（m为凸包上的角点个数），但是实际上按照这道题的要求，直接遍历角点暴力求最长距离也足够了，复杂度是O（m^2）。我使用的是暴力求解方法。