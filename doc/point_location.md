---
typora-root-url: ./
---

# Which Wall are You Looking at 报告

# 点定位实验报告

软博21 沈冠霖 2021312593

## 1.基本思路

我使用第六讲Point Location讲到的梯形图（Trapezoidal Map）数据结构和查询算法完成了这一题目，整体实现流程参考了https://blog.csdn.net/weixin_44800504/article/details/111402001和https://blog.csdn.net/weixin_44800504/article/details/111408905?spm=1001.2014.3001.5502。

这一数据结构和查询算法分为两部分。第一部分是数据结构构建，随机打乱输入的线之后，一根一根插入现有的梯形图数据结构，构造整体数据结构。第二部分是查询算法，对每个输入顶点，在数据结构中查找对应的梯形，进而得到对应的直线id。

按照PPT的讲解，构造部分，期望的梯形图节点个数为O(n)，期望空间复杂度为O(n)，而期望时间复杂度为O(nlogn)。查询部分每次的空间复杂度为O(1)，而时间复杂度为每次O(logn)，共m次查询。整体上，期望的空间复杂度为O(m+n)，时间复杂度为O((m+n)logn)。

## 2.实现细节

### 2.1 数据结构定义

梯形图的节点分为三类：点、线和梯形。这三类节点都需要存储其父亲节点们（梯形节点可能有多个父亲）和左右儿子节点（梯形没有儿子节点）。具体定义如下：

```c++
class Node
{
public:
    int type; //the type of each node, 1:point 2:line 3:trap
    Node* left_son = NULL;
    Node* right_son = NULL;
    vector<Node*> fathers;
};
```

点节点是非叶子节点，其定义是输入的线的某个端点。其具体定义如下：

```c++
class PointNode : public Node 
{
public:
    Point* point = NULL; //the point of the node
    PointNode(Point* p)
    {
        this->type = POINT;
        this->point = p;
    }
};
```

在查询中的规则是：当输入点的x坐标严格小于这个点的x坐标，则到左儿子，否则到右儿子。

```C++
double point_x = ((PointNode*)node)->point->x;
if(p->x < point_x)
{
    return this->SearchPoint(node->left_son, p);
}
else 
{
    return this->SearchPoint(node->right_son, p);
}
```

线节点是非叶子节点，其定义是输入的某条线，其具体定义如下：

```C++
class LineNode : public Node 
{
public:
    Line* line = NULL;
    LineNode(Line* l)
    {
        this->type = LINE;
        this->line = l;
    }
};
```

在查询中的规则是：当输入点严格在线上方（不包括共线），则到左儿子，否则到右儿子。

```c++
Line* line = ((LineNode*)node)->line;
double area2 = Area2(line->s, line->t, p);
if(area2 > 0)
{
    return this->SearchPoint(node->left_son, p);
}
else 
{
    return this->SearchPoint(node->right_son, p);
}
```

梯形节点是叶子节点。梯形由其上方、下方的两条线，和左右的x坐标定义，具体如下：

```c++
class Trap
{
public:
    double left;
    double right;
    Line* up = NULL;
    Line* down = NULL;
    Trap(double left_, double right_, Line* up_, Line* down_)
    {
        this->left = left_;
        this->right = right_;
        this->up = up_;
        this->down = down_;
    }
};
```

梯形节点虽然是叶子结点，但是为了实现插入-删除，需要记录梯形拓扑信息。按照本文实现的算法，只需要记录四个拓扑信息：当前梯形左上、左下、右上、右下的相邻梯形。如果左侧只有一个梯形，则左上和左下是同一个梯形，如果左侧没有梯形这两个就为空，右侧同理。

### 2.2 具体的构造方法

我们将整个区域初始化成一个大的梯形子节点，然后打乱输入线的顺序，进行随机的逐一插入。每次插入一条线的流程如下：

1. 使用查找算法查找到线左顶点所在的叶子节点，之后利用叶子结点的拓扑信息查找到所有这条线穿过的叶子结点。这里假设有k个叶子节点，k>=1。
2. 对于最左和最右的叶子节点，在线段左顶点左侧和由顶点右侧分别切分出新的叶子结点L和R。对于每个叶子结点Ti，在线段上方和下方分别切出两个叶子结点Ai,Bi。按照课件的单一端点/无端点情形，构造出对应的线节点和点节点，更新他们的父亲-儿子关系。而且要更新相应的拓扑关系：L的左上、左下节点和原始叶子结点T_1一样，右上、右下节点分别是A_1,B_1；R的右上_右下节点和原始叶子节点T_k一样，左上、左下节点分别是A_k,B_k；A_i的左上、右上节点可能继承原始叶子结点T_i的相应拓扑属性，B_i的左下、右下节点也可能继承原始叶子结点T_i的相应拓扑属性。
3. 对于上方叶子结点列表A_i和下方叶子结点列表B_i，进行相邻节点合并。合并的规则是这样：如果两个相邻梯形节点的上、下直线完全相同，则将两个相邻节点合并，更新其梯形属性、父子关系和拓扑关系。

可以看出，第一步查找的时间复杂度是O(logn)（根据课件的分析，查找复杂度的期望是如此的）, 每一次插入的时间、空间复杂度都是O(k)的，因为k的期望是O(1)的，因此整体构造的期望时间复杂度是O(nlogn)，空间复杂度是O(n)。

整体流程较为繁琐，这里不列出代码了，只呈现其示意图。

![trapezoid_map](/trapezoid_map.jpg)

### 2.3 具体的查找方法

一方面，这个数据结构能正确处理以下两种情形：待查找的点位于梯形内部，以及待查找的点位于梯形上下边界的情形。但是难以处理待查找的点位于梯形左右边界的情形。另一方面，这个数据结构无法处理竖直方向的直线。因此，我们进行了特殊判断，整体的查找流程如下：

在查找之前，预先将所有输入线段分别按照左端点坐标s_x和右端点坐标t_x升序排序，得到两个列表s和t。同时筛选出不是竖直方向的直线，用来构造梯形图。这一步空间复杂度是O(n)，时间复杂度是O(nlogn)。

对于每次查找，使用梯形图正常查找输入点的对应梯形T，对应上方线段l_1和到上方线段的距离d_1。这一步空间复杂度是O(1)，时间复杂度是O(logn)。

在s和t中分别进行二分查找，搜索所有线段左端点/右端点x坐标和输入点x坐标一样的线段，在这些线段中找到在点上方且距离点距离d最近的线段l。如果l比上一步得到的l_1更优，就选用l作为输出。这一步空间复杂度是O(1)，时间复杂度是O(logn)。

可以看出，这一步特判操作使得预处理时间复杂度增加了O(n)，空间复杂度增加了O(nlogn)。每次查询的空间复杂度增加了O(1)，时间复杂度增加了O(logn)。并不影响整体的时空复杂度。

## 3.其他细节

由于梯形图每个梯形叶子结点有不止一个父亲节点，因此不能直接用递归的方法进行内存清理。而梯形叶子结点需要频繁增删，因此最好选用STL的set数据结构进行处理，空间复杂度是O(n)，时间复杂度是O(nlogn)。但是经过测试，增加这一内存清理模块后，在oj上会有超时现象，因为整体处理本身就十分繁琐，加入内存清理模块后常数已经大到不可接受，因此我没有在实际代码中加入这一部分。当然，如果要将这个数据结构封装起来使用，这一部分